# Task 17: grGetProcAddress Optimization

## Summary
Optimize `grGetProcAddress()` function lookup from O(n) linear search to O(1) or O(log n) by using sorted binary search or hash table.

## Current State

**File:** `src/glide3x_get.c:348-361`

```c
GrProc __stdcall grGetProcAddress(char *procName)
{
    if (!procName) {
        return NULL;
    }

    for (int i = 0; g_proc_table[i].name != NULL; i++) {
        if (strcmp(g_proc_table[i].name, procName) == 0) {
            return g_proc_table[i].proc;
        }
    }

    return NULL;
}
```

### Function Table Size
The `g_proc_table` array contains ~40 function entries (lines 246-332):
- Initialization functions (3)
- Context management (6)
- Buffer operations (3)
- Drawing functions (3)
- Combine/blending (6)
- Depth buffer (4)
- Texture functions (10)
- LFB functions (4)
- Fog functions (3)
- Misc functions (10)

## Problem Analysis

### Linear Search Complexity
- Worst case: 40 string comparisons per lookup
- Average case: ~20 string comparisons
- Each `strcmp` scans until mismatch or null terminator

### When This Matters (and When It Doesn't)
`grGetProcAddress` is called:
- During application initialization to resolve function pointers
- Typically once per function, cached by the application
- **NOT** during rendering

**Reality Check:** This is almost certainly NOT a performance bottleneck. Games call this at startup, cache the pointers, and never call it again during gameplay.

## Why This Task Exists
Despite being very low priority, optimizing this is:
1. A good exercise in data structure choice
2. Negligible risk
3. Could matter if a game repeatedly resolves functions (unlikely but possible)

## Proposed Solutions

### Solution 1: Sort Table + Binary Search

Sort the table alphabetically and use binary search:

```c
/* Pre-sorted alphabetically */
static struct {
    const char *name;
    GrProc proc;
} g_proc_table[] = {
    {"grAlphaBlendFunction", (GrProc)grAlphaBlendFunction},
    {"grAlphaCombine", (GrProc)grAlphaCombine},
    {"grAlphaTestFunction", (GrProc)grAlphaTestFunction},
    /* ... sorted ... */
    {"grVertexLayout", (GrProc)grVertexLayout},
    {NULL, NULL}
};

static int g_proc_table_count = 0;  /* Computed at init */

/* Initialize count once */
static void init_proc_table_count(void) {
    if (g_proc_table_count == 0) {
        while (g_proc_table[g_proc_table_count].name != NULL) {
            g_proc_table_count++;
        }
    }
}

GrProc __stdcall grGetProcAddress(char *procName)
{
    if (!procName) return NULL;

    init_proc_table_count();

    int left = 0;
    int right = g_proc_table_count - 1;

    while (left <= right) {
        int mid = (left + right) / 2;
        int cmp = strcmp(procName, g_proc_table[mid].name);

        if (cmp == 0) {
            return g_proc_table[mid].proc;
        } else if (cmp < 0) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return NULL;
}
```

**Complexity:** O(log n) = ~6 comparisons max for 40 entries
**Effort:** Medium - need to manually sort the table

### Solution 2: Perfect Hash

Generate a minimal perfect hash for the function names:

```c
/* Perfect hash generated by gperf or similar tool */
static unsigned int hash_proc_name(const char *name) {
    /* ... hash function tuned for these specific names ... */
}

GrProc __stdcall grGetProcAddress(char *procName)
{
    if (!procName) return NULL;

    unsigned int idx = hash_proc_name(procName);
    if (idx < PROC_TABLE_SIZE &&
        strcmp(g_proc_table[idx].name, procName) == 0) {
        return g_proc_table[idx].proc;
    }

    return NULL;
}
```

**Complexity:** O(1) - single hash + single strcmp
**Effort:** High - need to generate and maintain perfect hash

### Solution 3: Hash Table

Use a simple hash table with chaining:

```c
#define PROC_HASH_SIZE 64  /* Power of 2 for fast modulo */

static struct proc_entry {
    const char *name;
    GrProc proc;
    struct proc_entry *next;
} *g_proc_hash[PROC_HASH_SIZE];

static unsigned int simple_hash(const char *str) {
    unsigned int hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c;  /* hash * 33 + c */
    }
    return hash & (PROC_HASH_SIZE - 1);
}

static void init_proc_hash(void) {
    static int initialized = 0;
    if (initialized) return;

    for (int i = 0; g_proc_table[i].name != NULL; i++) {
        unsigned int idx = simple_hash(g_proc_table[i].name);
        /* Insert at head of chain */
        g_proc_table[i].next = g_proc_hash[idx];
        g_proc_hash[idx] = &g_proc_table[i];
    }
    initialized = 1;
}

GrProc __stdcall grGetProcAddress(char *procName)
{
    if (!procName) return NULL;

    init_proc_hash();

    unsigned int idx = simple_hash(procName);
    struct proc_entry *entry = g_proc_hash[idx];

    while (entry) {
        if (strcmp(entry->name, procName) == 0) {
            return entry->proc;
        }
        entry = entry->next;
    }

    return NULL;
}
```

**Complexity:** O(1) average case, O(n) worst case
**Effort:** Medium

### Solution 4: Do Nothing

Given that:
- This function is called at initialization only
- Results are cached by the application
- Total time spent here is negligible

The correct solution may be to leave it as-is and focus on real bottlenecks.

## Recommended Implementation

**Solution 4** (do nothing) is the pragmatic choice.

If you really want to optimize it, **Solution 1** (sorted binary search) is:
- Simple to implement
- No runtime initialization needed
- Predictable performance
- Easy to verify correctness

## Files to Modify

| File | Changes |
|------|---------|
| `src/glide3x_get.c` | Sort `g_proc_table`, implement binary search |

## Risk Assessment
**Risk: VERY LOW**
- Isolated change to one function
- Called only at initialization
- Easy to test
- Easy to revert

## Testing Requirements
- [ ] All function lookups return correct pointers
- [ ] NULL input returns NULL
- [ ] Unknown function names return NULL
- [ ] No crashes or hangs

## Expected Impact

| Metric | Before | After (Binary Search) |
|--------|--------|----------------------|
| Comparisons (worst) | 40 | 6 |
| Comparisons (average) | 20 | 5 |
| Time saved per call | - | ~microseconds |
| Calls per game session | ~40 | ~40 |
| Total time saved | - | ~negligible |

**Overall Impact:** NEGLIGIBLE

This optimization saves perhaps 100 microseconds total at game startup. It's not worth implementing unless you have nothing better to do.

## Dependencies
- Independent of other tasks
- Lowest priority in the entire optimization list
- Do this last, if ever

## Notes
- The linear search is actually cache-friendly since the table is small and contiguous
- Modern CPUs are very good at branch prediction for simple loops
- The real performance wins are in the per-pixel rendering path, not initialization
- Consider this task "nice to have" rather than "should do"
- If implementing, alphabetically sorting the table also improves code readability

## Alternative: Remove grGetProcAddress Entirely

Some Glide implementations export all functions directly from the DLL, making grGetProcAddress unnecessary. Applications using GetProcAddress/dlsym on the DLL itself don't need grGetProcAddress.

Check if any target games actually use grGetProcAddress. If not, it's dead code.
